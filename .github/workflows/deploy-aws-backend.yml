name: Deploy AWS Backend + Vercel Frontend

on:
  push:
    branches:
      - main
      - feat/aws-server
  workflow_dispatch:
    inputs:
      branch:
        description: "Branch para deploy"
        required: true
        default: "feat/aws-server"

concurrency:
  group: deploy-cloud-monitoring-${{ github.ref_name || github.event.inputs.branch || 'manual' }}
  cancel-in-progress: true

jobs:
  deploy_backend_aws:
    runs-on: ubuntu-latest
    steps:
      - name: Resolve branch
        id: vars
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "branch=${{ github.event.inputs.branch }}" >> "$GITHUB_OUTPUT"
          else
            echo "branch=${{ github.ref_name }}" >> "$GITHUB_OUTPUT"
          fi

      - name: Validate deploy secrets
        env:
          AWS_EC2_HOST: ${{ secrets.AWS_EC2_HOST }}
          AWS_EC2_USER: ${{ secrets.AWS_EC2_USER }}
          AWS_EC2_SSH_KEY: ${{ secrets.AWS_EC2_SSH_KEY }}
          BACKEND_URL: ${{ secrets.BACKEND_URL }}
          ADMIN_EMAIL: ${{ secrets.ADMIN_EMAIL }}
          ADMIN_PASSWORD: ${{ secrets.ADMIN_PASSWORD }}
          MQTT_AMAZON_CA_PEM_B64: ${{ secrets.MQTT_AMAZON_CA_PEM_B64 }}
          MQTT_DEVICE_CRT_B64: ${{ secrets.MQTT_DEVICE_CRT_B64 }}
          MQTT_PRIVATE_KEY_B64: ${{ secrets.MQTT_PRIVATE_KEY_B64 }}
        run: |
          set -euo pipefail
          for name in AWS_EC2_HOST AWS_EC2_USER AWS_EC2_SSH_KEY BACKEND_URL ADMIN_EMAIL ADMIN_PASSWORD MQTT_AMAZON_CA_PEM_B64 MQTT_DEVICE_CRT_B64 MQTT_PRIVATE_KEY_B64; do
            if [ -z "${!name:-}" ]; then
              echo "::error::Secret obrigatorio ausente: ${name}"
              exit 1
            fi
          done
          if ! printf '%s' "${AWS_EC2_SSH_KEY}" | grep -Eq "PRIVATE KEY|PuTTY-User-Key-File-"; then
            echo "::error::AWS_EC2_SSH_KEY invalida. Formatos aceitos: OpenSSH/PEM ou PPK (PuTTY)."
            exit 1
          fi

      - name: Prepare SSH private key file
        id: sshkey
        env:
          AWS_EC2_SSH_KEY: ${{ secrets.AWS_EC2_SSH_KEY }}
        run: |
          set -euo pipefail
          RAW_KEY_PATH="${RUNNER_TEMP}/ec2_deploy_key.raw"
          KEY_PATH="${RUNNER_TEMP}/ec2_deploy_key"
          umask 077

          # Aceita segredo com quebras reais de linha ou com "\n" literal.
          if printf '%s' "${AWS_EC2_SSH_KEY}" | grep -q '\\n'; then
            printf '%b\n' "${AWS_EC2_SSH_KEY}" > "${RAW_KEY_PATH}"
          else
            printf '%s\n' "${AWS_EC2_SSH_KEY}" > "${RAW_KEY_PATH}"
          fi

          sed -i 's/\r$//' "${RAW_KEY_PATH}"

          # Suporta chave PPK (PuTTY) convertendo para OpenSSH no runner.
          if grep -q '^PuTTY-User-Key-File-' "${RAW_KEY_PATH}"; then
            sudo apt-get update -y
            sudo apt-get install -y putty-tools
            puttygen "${RAW_KEY_PATH}" -O private-openssh -o "${KEY_PATH}"
          else
            cp "${RAW_KEY_PATH}" "${KEY_PATH}"
          fi

          chmod 600 "${KEY_PATH}"

          if ! ssh-keygen -yf "${KEY_PATH}" >/dev/null 2>&1; then
            echo "::error::AWS_EC2_SSH_KEY invalida ou nao foi possivel converter para OpenSSH."
            exit 1
          fi

          echo "key_path=${KEY_PATH}" >> "$GITHUB_OUTPUT"

      - name: Bootstrap and deploy via SSH
        env:
          BRANCH: ${{ steps.vars.outputs.branch }}
          APP_DIR: ${{ secrets.AWS_EC2_APP_DIR }}
          REPO_URL: ${{ secrets.AWS_REPO_URL }}
          FRONTEND_URL: ${{ secrets.FRONTEND_URL }}
          BACKEND_URL: ${{ secrets.BACKEND_URL }}
          ADMIN_EMAIL: ${{ secrets.ADMIN_EMAIL }}
          ADMIN_PASSWORD: ${{ secrets.ADMIN_PASSWORD }}
          BACKEND_PUBLIC_PORT: ${{ secrets.BACKEND_PUBLIC_PORT }}
          BROKER: ${{ secrets.BROKER }}
          MQTT_PORT: ${{ secrets.MQTT_PORT }}
        uses: appleboy/ssh-action@v1.2.2
        with:
          host: ${{ secrets.AWS_EC2_HOST }}
          username: ${{ secrets.AWS_EC2_USER }}
          key_path: ${{ steps.sshkey.outputs.key_path }}
          port: ${{ secrets.AWS_EC2_PORT || '22' }}
          envs: BRANCH,APP_DIR,REPO_URL,FRONTEND_URL,BACKEND_URL,ADMIN_EMAIL,ADMIN_PASSWORD,BACKEND_PUBLIC_PORT,BROKER,MQTT_PORT
          script: |
            set -euo pipefail

            if [ -z "${APP_DIR}" ]; then
              APP_DIR="$HOME/cloud-monitoring"
            fi
            if [ -z "${REPO_URL}" ]; then
              REPO_URL="https://github.com/Monitoramento-de-Conectividade/cloud-monitoring.git"
            fi
            if [ -z "${FRONTEND_URL:-}" ]; then
              FRONTEND_URL="https://cloud-monitoring.vercel.app"
            fi
            if [ -z "${BACKEND_PUBLIC_PORT:-}" ]; then
              BACKEND_PUBLIC_PORT="8008"
            fi
            if [ -z "${BROKER:-}" ]; then
              BROKER="a19mijesri84u2-ats.iot.us-east-1.amazonaws.com"
            fi
            if [ -z "${MQTT_PORT:-}" ]; then
              MQTT_PORT="8883"
            fi

            if [ ! -d "${APP_DIR}/.git" ]; then
              mkdir -p "${APP_DIR}"
              git clone "${REPO_URL}" "${APP_DIR}"
            fi

            cd "${APP_DIR}"
            git fetch origin
            if git show-ref --verify --quiet "refs/heads/${BRANCH}"; then
              git checkout "${BRANCH}"
            else
              git checkout -b "${BRANCH}" "origin/${BRANCH}"
            fi
            git pull --ff-only origin "${BRANCH}"

            if ! command -v docker >/dev/null 2>&1; then
              chmod +x scripts/ec2-install-docker.sh
              sudo ./scripts/ec2-install-docker.sh
            fi
            sudo systemctl enable docker || true
            sudo systemctl start docker || true

            mkdir -p certs logs_mqtt

            tmp_dir="$(mktemp -d)"
            trap 'rm -rf "${tmp_dir}"' EXIT

            cat > "${tmp_dir}/amazon_ca.secret" <<'EOF_SECRET'
            ${{ secrets.MQTT_AMAZON_CA_PEM_B64 }}
            EOF_SECRET
            cat > "${tmp_dir}/device_crt.secret" <<'EOF_SECRET'
            ${{ secrets.MQTT_DEVICE_CRT_B64 }}
            EOF_SECRET
            cat > "${tmp_dir}/private_key.secret" <<'EOF_SECRET'
            ${{ secrets.MQTT_PRIVATE_KEY_B64 }}
            EOF_SECRET

            write_pem_secret() {
              local source_file="$1"
              local target_file="$2"
              local label="$3"

              # Aceita secret em PEM ASCII (BEGIN/END) e mantem compatibilidade com base64.
              if grep -q -- "-----BEGIN " "${source_file}"; then
                sed 's/\r$//' "${source_file}" > "${target_file}"
              else
                tr -d '\r\n\t ' < "${source_file}" | base64 -d > "${target_file}" 2>/dev/null || {
                  echo "Erro: secret ${label} nao esta em PEM ASCII nem em base64 valido." >&2
                  exit 1
                }
              fi

              if ! grep -q -- "-----BEGIN " "${target_file}"; then
                echo "Erro: secret ${label} invalido (header PEM ausente)." >&2
                exit 1
              fi
            }

            write_pem_secret "${tmp_dir}/amazon_ca.secret" certs/amazon_ca.pem "MQTT_AMAZON_CA_PEM_B64"
            write_pem_secret "${tmp_dir}/device_crt.secret" certs/device.pem.crt "MQTT_DEVICE_CRT_B64"
            write_pem_secret "${tmp_dir}/private_key.secret" certs/private.pem.key "MQTT_PRIVATE_KEY_B64"

            for cert_path in certs/amazon_ca.pem certs/device.pem.crt certs/private.pem.key; do
              if [ ! -s "${cert_path}" ]; then
                echo "Erro: certificado invalido/ausente em ${cert_path}" >&2
                exit 1
              fi
            done

            chmod 600 certs/amazon_ca.pem certs/device.pem.crt certs/private.pem.key

            cat > .env.backend <<EOF
            BACKEND_PUBLIC_PORT=${BACKEND_PUBLIC_PORT}
            BROKER=${BROKER}
            MQTT_PORT=${MQTT_PORT}
            CORS_ALLOWED_ORIGINS=${FRONTEND_URL}
            AUTH_COOKIE_SAMESITE=None
            AUTH_COOKIE_SECURE=1
            AUTH_BASE_URL=${BACKEND_URL}
            REQUIRE_APPLY_TO_START=0
            HISTORY_MODE=merge
            DASHBOARD_REFRESH_SEC=20
            API_STATE_CACHE_TTL_SEC=5
            API_QUALITY_CACHE_TTL_SEC=5
            MAX_EVENTS_PER_PIVOT=800
            MAX_EVENTS_PER_PIVOT_PANEL=800
            MAX_EVENTS_PER_PIVOT_LIST=400
            PROBE_DEFAULT_INTERVAL_SEC=900
            PROBE_MIN_INTERVAL_SEC=180
            AUTH_FIXED_ADMIN_ENABLED=1
            AUTH_FIXED_ADMIN_EMAIL=${ADMIN_EMAIL}
            AUTH_FIXED_ADMIN_PASSWORD=${ADMIN_PASSWORD}
            AUTH_EMAIL_MODE=console
            EOF

            sudo docker compose up -d --build backend
            sudo docker compose ps backend
            sudo docker logs --tail=120 cloud-monitoring-backend || true

            for _ in $(seq 1 30); do
              if curl -fsS "http://127.0.0.1:8008/login" >/dev/null; then
                echo "Healthcheck local OK"
                exit 0
              fi
              sleep 5
            done

            echo "Erro: healthcheck local falhou apos deploy." >&2
            exit 1

  deploy_frontend_vercel:
    needs: deploy_backend_aws
    runs-on: ubuntu-latest
    steps:
      - name: Validate Vercel deploy hook secret
        env:
          VERCEL_FRONTEND_DEPLOY_HOOK_URL: ${{ secrets.VERCEL_FRONTEND_DEPLOY_HOOK_URL }}
        run: |
          set -euo pipefail
          if [ -z "${VERCEL_FRONTEND_DEPLOY_HOOK_URL:-}" ]; then
            echo "::error::Secret obrigatorio ausente: VERCEL_FRONTEND_DEPLOY_HOOK_URL"
            exit 1
          fi

      - name: Trigger Vercel deploy
        env:
          VERCEL_FRONTEND_DEPLOY_HOOK_URL: ${{ secrets.VERCEL_FRONTEND_DEPLOY_HOOK_URL }}
        run: |
          set -euo pipefail
          response="$(curl -fsS -X POST "${VERCEL_FRONTEND_DEPLOY_HOOK_URL}")"
          echo "Vercel deploy disparado."
          echo "${response}"
